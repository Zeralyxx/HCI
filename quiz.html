<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&family=IBM+Plex+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <title>MindBlast | Quiz</title>
    <style>
        :root {
            --bg-light: #f0f2f5;
            --white: #ffffff;
            --gray: #e0e0e0;
            --light-gray: #f0f0f0; /* Added for locked buttons */
            --green: #4CAF50; /* Changed to a stronger green for correct */
            --red: #F44336; /* Changed to a stronger red for incorrect */
            --correct-bg: #d2f6d2; /* Light green background */
            --incorrect-bg: #f8d2d2; /* Light red background */
            --rounded: 20px;
            --shadow: 0 8px 20px rgba(0, 0, 0, 0.15); /* Slightly stronger shadow */
            --primary-gradient: linear-gradient(135deg, #2E0B40, #3E1A58, #4E2A70);
            --primary-dark: #2E0B40;
            --primary-medium: #4E2A70;

            /* Font variables */
            --font-heading: 'Fredoka', sans-serif;
            --font-body: 'IBM Plex Sans', sans-serif;
            --text-dark: #333333;
            --text-light-gray: #555555;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body); /* Using IBM Plex Sans for body */
            margin: 0;
            background: var(--primary-gradient);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            padding: 16px;
            color: var(--text-dark); /* Default text color */
        }

        #start-screen, #quiz-screen {
            background: var(--white);
            padding: 24px;
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            width: 100%;
            max-width: 420px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            display: flex; /* Ensure flex for internal layout */
            flex-direction: column; /* Stack children vertically */
            gap: 16px; /* Consistent spacing between elements */
        }

        #quiz-screen {
            display: none; /* Hidden by default, shown by JS */
        }

        h1, h2, h3 {
            font-family: var(--font-heading); /* Fredoka for headings */
            margin-bottom: 8px; /* Reduced margin for tighter look */
            color: var(--primary-dark);
        }

        p {
            font-family: var(--font-body);
            margin-bottom: 16px;
            color: var(--text-light-gray);
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 12px 15px; /* Added horizontal padding */
            margin: 8px 0;
            border: none;
            border-radius: var(--rounded);
            font-size: 17px; /* Slightly larger font */
            font-weight: bold; /* Make buttons bolder */
            cursor: pointer;
            background-color: var(--gray);
            color: var(--text-dark);
            transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }

        .btn .icon-left {
            font-size: 22px; /* Slightly larger emoji */
            margin-right: 10px;
        }

        .btn .lock-icon {
            font-size: 20px;
            position: absolute;
            right: 15px;
            color: var(--text-light-gray);
        }

        /* Style for locked buttons */
        .btn.locked {
            background-color: var(--light-gray); /* Lighter gray for locked buttons */
            cursor: not-allowed;
            color: #888; /* Dim text for locked state */
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05); /* Subtle inner shadow */
        }

        .btn.locked:hover {
            background-color: var(--light-gray); /* Prevent hover effect on locked buttons */
            transform: none;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
        }

        .btn:not(.locked):hover {
            background-color: #c0c0c0; /* Darker gray on hover */
            transform: translateY(-2px); /* Slight lift effect */
            box-shadow: var(--shadow); /* Apply shadow on hover */
        }

        /* Specific style for Claim Certificate Button */
        #claim-btn-icon {
            background: linear-gradient(45deg, #8A2BE2, #A020F0); /* Purple gradient */
            color: var(--white);
            margin-top: 20px; /* More space above it */
            box-shadow: 0 4px 10px rgba(138, 43, 226, 0.3); /* Shadow matching gradient */
        }

        #claim-btn-icon:hover {
            background: linear-gradient(45deg, #9933FF, #B366FF); /* Lighter gradient on hover */
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(138, 43, 226, 0.4);
        }

        .option {
            background: var(--gray);
            transition: background 0.3s ease, transform 0.2s ease;
        }

        .option:hover:not(.correct):not(.incorrect) {
             background-color: #c0c0c0;
             transform: translateY(-2px);
        }

        .correct {
            background-color: var(--correct-bg) !important;
            color: var(--green);
            border: 1px solid var(--green);
            animation: pulseCorrect 0.5s ease-out; /* Add animation */
        }

        .incorrect {
            background-color: var(--incorrect-bg) !important;
            color: var(--red);
            border: 1px solid var(--red);
            animation: shakeIncorrect 0.5s ease-out; /* Add animation */
        }

        @keyframes pulseCorrect {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        @keyframes shakeIncorrect {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }


        #icon-placeholder {
            font-size: 80px; /* Larger icon */
            background: var(--light-gray); /* Lighter background */
            border-radius: var(--rounded);
            padding: 20px;
            width: 120px; /* Larger box */
            height: 120px;
            color: var(--primary-dark); /* Darker icon color */
            margin: 20px auto; /* More margin around it */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1); /* Subtle inner shadow */
        }

        #progress {
            font-weight: bold;
            margin-top: 12px;
            font-size: 15px;
            color: var(--text-light-gray);
        }

        .progress-container {
            width: 100%;
            background-color: var(--gray);
            border-radius: var(--rounded);
            overflow: hidden;
            height: 16px;
            margin: 8px 0;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .progress-bar {
            height: 100%;
            background-color: var(--green); /* Using the defined green */
            width: 0%;
            transition: width 0.3s ease;
        }

        #timer {
            position: absolute;
            top: 20px; /* Adjusted for better spacing */
            right: 24px;
            font-weight: bold;
            color: var(--primary-dark); /* Darker color for timer */
            font-size: 18px; /* Slightly larger timer */
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #score-display {
            position: absolute;
            top: 20px; /* Aligned with timer */
            left: 24px; /* Changed to left for clarity */
            text-align: left;
            font-weight: bold;
            color: var(--primary-dark);
            font-size: 18px;
            z-index: 10;
        }
        #score-feedback {
            color: var(--green); /* Green for positive feedback */
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease;
            position: absolute; /* Position relative to score-display */
            right: 0; /* Align to the right of its parent (score-display) */
            top: 25px; /* Adjust vertical position */
            transform: translateY(0);
        }

        #score-feedback.show {
            opacity: 1;
            transform: translateY(-10px); /* Move up */
        }

        .close {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 999;
            color: var(--white); /* White for visibility on gradient */
            text-decoration: none;
            font-size: 28px;
            padding: 4px;
            border-radius: 50%;
            transition: background 0.3s ease;
            display: flex; /* For perfect centering of the icon */
            align-items: center;
            justify-content: center;
            width: 40px; /* Make it a clickable circle */
            height: 40px;
        }

        .close:hover {
            background-color: rgba(255, 255, 255, 0.2); /* Lighter hover for visibility */
        }

        /* Modal Styles (Consistent with existing and added recommendations) */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out; /* Added fade in to modal display */
        }

        .modal-content {
            background-color: var(--white);
            margin: auto;
            padding: 30px; /* More padding */
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            width: 90%; /* Increased width for responsiveness */
            max-width: 600px;
            text-align: center;
            position: relative;
            animation: modalPop 0.3s ease-out; /* Pop animation */
            display: flex; /* Use flexbox for content arrangement */
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Spacing between elements inside modal */
        }

        .close-modal-btn {
            color: #aaa;
            position: absolute;
            top: 15px; /* Adjusted position */
            left: 20px; /* Adjusted position */
            font-size: 30px; /* Larger close icon */
            font-weight: bold;
            cursor: pointer;
            line-height: 1; /* Better alignment */
        }

        .close-modal-btn:hover,
        .close-modal-btn:focus {
            color: var(--text-dark);
        }

        .certificate-preview {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #download-certificate-btn {
            background-color: var(--primary-medium); /* Use a primary color */
            color: var(--white);
            margin-top: 15px; /* Adjust margin */
            font-size: 16px;
            padding: 10px 20px;
            border-radius: 10px; /* Slightly less rounded than global buttons */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #download-certificate-btn:hover {
            background-color: #6a0dad; /* Darker primary on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPop {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }


        /* New styles for general message modal */
        #message-modal .modal-content {
            max-width: 450px; /* Smaller max-width for alerts */
            padding: 25px;
            gap: 10px;
        }

        #message-modal .modal-content h3 {
            margin-top: 0;
            color: var(--primary-dark);
            font-size: 24px;
        }

        #message-modal .modal-content p {
            margin-bottom: 15px;
            color: var(--text-light-gray);
            font-size: 16px;
            line-height: 1.5;
        }

        #message-modal .modal-content button {
            background-color: var(--primary-medium); /* A primary color, e.g., purple */
            color: white;
            border: none;
            padding: 12px 25px; /* Larger padding */
            border-radius: var(--rounded); /* Use general rounded style */
            cursor: pointer;
            font-size: 17px;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }

        #message-modal .modal-content button:hover {
            background-color: #6a0dad;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        /* Small Modal Specific Styles (for quit confirmation) */
        .small-modal {
          max-width: 400px; /* Make this modal a bit smaller */
          padding: 30px;
        }

        .small-modal h2 {
          color: #333;
          margin-bottom: 15px;
        }

        .small-modal p {
          margin-bottom: 25px;
          line-height: 1.5;
          color: #555;
        }

        .modal-actions {
          display: flex;
          justify-content: space-around;
          gap: 15px; /* Space between buttons */
        }

        .modal-actions .btn {
          flex-grow: 1; /* Make buttons fill available space */
          margin: 0; /* Override default btn margin */
        }

        .red-btn {
          background-color: #dc3545; /* Bootstrap-like red for danger */
        }

        .red-btn:hover {
          background-color: #c82333;
        }

        .green-btn {
          background-color: #28a745; /* Bootstrap-like green for success/continue */
        }

        .green-btn:hover {
          background-color: #218838;
        }


        @media (max-width: 480px) {
            #start-screen, #quiz-screen {
                padding: 16px;
                gap: 12px;
            }

            .btn {
                font-size: 15px;
                padding: 10px;
            }

            .btn .icon-left {
                font-size: 18px;
            }

            .btn .lock-icon {
                font-size: 18px;
            }

            #timer, #score-display {
                top: 15px;
                font-size: 16px;
            }

            #score-display {
                left: 16px;
            }

            #timer {
                right: 16px;
            }

            #icon-placeholder {
                font-size: 70px;
                width: 100px;
                height: 100px;
                margin: 15px auto;
            }

            .modal-content {
                padding: 20px;
                gap: 10px;
            }

            .close-modal-btn {
                font-size: 26px;
                top: 10px;
                left: 15px;
            }

            h1, h2 {
                font-size: 26px;
            }

            p {
                font-size: 14px;
            }
            #message-modal .modal-content h3 {
                font-size: 20px;
            }
            #message-modal .modal-content p {
                font-size: 14px;
            }
            #message-modal .modal-content button {
                font-size: 15px;
                padding: 10px 20px;
            }
        }

        #streak-feedback {
            color: var(--primary-medium); /* A prominent color for streak */
            font-size: 16px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease;
            position: absolute;
            left: 24px; /* Align with score-display */
            top: 45px; /* Adjust vertical position below score */
            transform: translateY(0);
        }

        #streak-feedback.show {
            opacity: 1;
            transform: translateY(-5px); /* Slight lift effect */
        }

        /* Add these new CSS rules to your <style> block */

        /* Base body transition for smooth background changes */
        body {
            transition: background 0.8s ease-in-out; /* Smooth transition for background */
        }
        
        /* Streak specific backgrounds */
        body.streak-2-bg {
            background: linear-gradient(135deg, #4CAF50, #66BB6A); /* Greenish for 2x streak */
        }
        
        body.streak-3-bg {
            background: linear-gradient(135deg, #FFC107, #FFD54F); /* Yellowish for 3x streak */
        }
        
        body.streak-4-bg {
            background: linear-gradient(135deg, #FF9800, #FFB74D); /* Orangish for 4x streak */
        }
        
        body.streak-5-bg {
            background: linear-gradient(135deg, #2196F3, #64B5F6); /* Bluish for 5x streak */
        }
        
        body.streak-6-bg {
            background: linear-gradient(135deg, #9C27B0, #CE93D8); /* Purplish for 6x streak */
        }
        
        body.streak-7-bg {
            background: linear-gradient(135deg, #F44336, #E57373); /* Reddish for 7x streak */
        }
        
        body.streak-8-bg {
            background: linear-gradient(135deg, #795548, #A1887F); /* Brownish for 8x streak */
        }
        
        body.streak-9-bg {
            background: linear-gradient(135deg, #00BCD4, #4DD0E1); /* Cyan for 9x streak */
        }
        
        body.streak-10-bg {
            background: linear-gradient(135deg, #C2185B, #F06292); /* Deep Pink for 10+ streak */
        }
    </style>
</head>
<body>

    <a href="home.html" class="close" aria-label="Close">
        <span class="material-symbols-outlined">close</span>
    </a>
    <audio id="bg-music" loop autoplay>
        <source src="music/background.mp3" type="audio/mp3" />
        Your browser does not support the audio element.
    </audio>



    <div id="start-screen">
        <h1>Start Quiz</h1>
        <p>Select difficulty:</p>
        <button class="btn difficulty-btn" id="easy-btn" data-difficulty="Easy">
            <span class="icon-left">üü¢</span> Easy
            <span class="material-symbols-outlined lock-icon" id="easy-lock-icon">lock_open</span>
        </button>
        <button class="btn difficulty-btn" id="medium-btn" data-difficulty="Medium">
            <span class="icon-left">üü°</span> Medium
            <span class="material-symbols-outlined lock-icon" id="medium-lock-icon">lock</span>
        </button>
        <button class="btn difficulty-btn" id="hard-btn" data-difficulty="Hard">
            <span class="icon-left">üî¥</span> Hard
            <span class="material-symbols-outlined lock-icon" id="hard-lock-icon">lock</span>
        </button>
        <button class="btn" id="claim-btn-icon">Claim Certificate</button>
    </div>

    <div id="quiz-screen">
        <div id="timer">‚è±Ô∏è 60s</div>
        <div id="score-display">
            <div id="total-score">Score: 0</div>
            <div id="score-feedback"></div>
            <div id="streak-feedback"></div>
        </div>
        <h2>What is this icon?</h2>
        <div id="icon-placeholder">üî≤</div>
        <div id="options"></div>
        <div id="progress">1/10</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>

    <div id="quit-confirm-modal" class="modal">
    <div class="modal-content small-modal">
      <h2>Quit Quiz?</h2>
      <p>Are you sure you want to quit? You will lose all progress for this quiz.</p>
      <div class="modal-actions">
        <button id="quit-yes-btn" class="btn red-btn">Yes, Quit</button>
        <button id="quit-no-btn" class="btn green-btn">No, Continue</button>
      </div>
    </div>
  </div>

    <div id="certificate-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal-btn material-symbols-outlined">close</span> <h2>üéâ Congratulations! üéâ</h2>
            <p>You've mastered the icons! Here's your certificate:</p>
            <canvas id="certificate-canvas" style="border: 1px solid #ddd; max-width: 100%; height: auto; display: block; margin: 20px auto;"></canvas>
            <button id="download-certificate-btn" class="btn">Download Certificate</button>
        </div>
    </div>

    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h3 id="message-modal-title"></h3>
            <p id="message-modal-text"></p>
            <button id="message-modal-ok-btn">OK</button>
        </div>
    </div>

    <script type="module">
    import {
        initializeApp
    } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-app.js";
    import { getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-firestore.js";

    import {
        getFirestore,
        collection,
        getDocs,
        addDoc,
        serverTimestamp,
        query,
        where,
        updateDoc,
        doc
    } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-firestore.js";
    import {
        getAuth,
        onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-auth.js";
    import {
        getAnalytics
    } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-analytics.js";

    const firebaseConfig = {
        apiKey: "AIzaSyAZLZPVAlZUJWLturWzJ3nqyceZbSIevl4",
        authDomain: "mindblast-icons.firebaseapp.com",
        projectId: "mindblast-icons",
        storageBucket: "mindblast-icons.firebasestorage.app",
        messagingSenderId: "807795058423",
        appId: "1:807795058423:web:2066a5d149852a43af55f2",
        measurementId: "G-LSJ3SWQP6M"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const analytics = getAnalytics(app);

    let quizData = [];
    let currentQuestion = 0;
    let score = 0;
    let scoreStreak = 0;
    let correctAnswers = 0;
    let difficulty = '';
    let questionStartTime = 0;
    let currentUser = null;
    let timePerQuestion = 20;
    let currentTimer = 0;
    let timerInterval;

    // Track completed difficulties for the current user
    let completedDifficulties = {
        Easy: false,
        Medium: false,
        Hard: false
    };

    const totalScoreDisplay = document.getElementById("total-score");
    const scoreFeedback = document.getElementById("score-feedback");
    const startScreen = document.getElementById("start-screen");
    const quizScreen = document.getElementById("quiz-screen");
    const iconPlaceholder = document.getElementById("icon-placeholder");
    const optionsDiv = document.getElementById("options");
    const progressText = document.getElementById("progress");
    const timerDisplay = document.getElementById("timer");

    const closeQuizBtn = document.querySelector('.close'); // This is the 'a' tag
    const quitConfirmModal = document.getElementById('quit-confirm-modal');
    const quitYesBtn = document.getElementById('quit-yes-btn');
    const quitNoBtn = document.getElementById('quit-no-btn');

    const easyBtn = document.getElementById("easy-btn");
    const mediumBtn = document.getElementById("medium-btn");
    const hardBtn = document.getElementById("hard-btn");

    const easyLockIcon = document.getElementById("easy-lock-icon");
    const mediumLockIcon = document.getElementById("medium-lock-icon");
    const hardLockIcon = document.getElementById("hard-lock-icon");

    const claimCertificateBtn = document.getElementById("claim-btn-icon");
    const certificateModal = document.getElementById("certificate-modal");
    const closeModalBtn = document.querySelector(".close-modal-btn");
    const downloadCertificateBtn = document.getElementById("download-certificate-btn");
    const certificateCanvas = document.getElementById('certificate-canvas');
    const ctx = certificateCanvas.getContext('2d');

    // New message modal elements
    const messageModal = document.getElementById('message-modal');
    const messageModalTitle = document.getElementById('message-modal-title');
    const messageModalText = document.getElementById('message-modal-text');
    const messageModalOkBtn = document.getElementById('message-modal-ok-btn');

    // Optional: Allow user interaction to resume music if browser blocks autoplay
    document.body.addEventListener("click", () => {
        if (bgMusic.paused) {
            bgMusic.play().catch(() => {});
        }
    });

    /**
 * Displays a general-purpose modal message.
 * Returns a Promise that resolves when the modal is dismissed by clicking OK or outside.
 * @param {string} title The title of the message.
 * @param {string} message The message content.
 * @param {number} [autoCloseDelay=0] Optional: If > 0, the modal will auto-close after this many milliseconds.
 */
function showMessageModal(title, message, autoCloseDelay = 0) {
    return new Promise(resolve => {
        messageModalTitle.textContent = title;
        messageModalText.textContent = message;

        // Ensure only the OK button is visible and properly reset
        messageModalOkBtn.style.display = 'block'; // Make sure OK button is visible
        messageModalOkBtn.onclick = null; // Clear previous listener

        let autoCloseTimer = null;

        const cleanupListeners = () => {
            messageModalOkBtn.onclick = null;
            messageModal.removeEventListener('click', clickOutsideHandler);
            if (autoCloseTimer) {
                clearTimeout(autoCloseTimer);
            }
        };

        const closeAndResolve = () => {
            messageModal.style.display = 'none';
            cleanupListeners();
            resolve(); // Resolve the promise when dismissed
        };

        // Attach new event listener to OK button
        messageModalOkBtn.onclick = closeAndResolve;

        // Named function for click outside handler to allow proper removal
        const clickOutsideHandler = function(event) {
            if (event.target === messageModal) {
                closeAndResolve();
            }
        };
        messageModal.addEventListener('click', clickOutsideHandler);

        messageModal.style.display = 'flex'; // Use flex to center content

        // Handle auto-close if delay is specified
        if (autoCloseDelay > 0) {
            autoCloseTimer = setTimeout(() => {
                closeAndResolve();
            }, autoCloseDelay);
        }
    });
}


    // Check login state and load user progress
    onAuthStateChanged(auth, async user => {
        if (user) {
            currentUser = user;
            // NEW: Check if email is verified
            if (!user.emailVerified) {
                // Disable all interactive elements on the start screen
                disableQuizInteractions(true);
                await showMessageModal( // Await here to block interactions until dismissed
                    "Email Not Verified",
                    "Please verify your email address to play quizzes and claim certificates. Check your inbox and spam folder, or go to your account page to resend the verification email."
                );
                return; // Stop further execution if email is not verified
            }

            // If user is logged in AND verified, proceed
            disableQuizInteractions(false); // Re-enable if previously disabled
            await loadUserProgress(); // Load user's completed difficulties
            updateDifficultyLocks(); // Update the UI based on loaded progress

        } else {
            // User is not logged in
            disableQuizInteractions(true); // Disable interactions for guests
            await showMessageModal("Login Required", "You must be logged in to play the quiz.");
            window.location.href = "auth.html"; // redirect to login
        }
    });

    /**
     * Disables or enables quiz start buttons and claim certificate button.
     * @param {boolean} disable True to disable, false to enable.
     */
    function disableQuizInteractions(disable) {
        const buttons = [easyBtn, mediumBtn, hardBtn, claimCertificateBtn];
        buttons.forEach(btn => {
            if (disable) {
                btn.classList.add('locked');
                btn.onclick = null;
            } else {
                // Only remove 'locked' if not already locked by difficulty progression
                if (!btn.dataset.lockedByDifficulty) { // Use a data attribute to track difficulty locks
                    btn.classList.remove('locked');
                }
                // onclick handlers will be re-assigned by updateDifficultyLocks or specific listeners
            }
        });
    }

    async function loadUserProgress() {
        if (!currentUser) return; // This check is already done by onAuthStateChanged
        const userRef = doc(db, "users", currentUser.uid);
        const userSnap = await getDoc(userRef);
        if (userSnap.exists()) {
            const userData = userSnap.data();
            completedDifficulties.Easy = userData.completedEasy || false;
            completedDifficulties.Medium = userData.completedMedium || false;
            completedDifficulties.Hard = userData.completedHard || false;
        }
    }

    function updateDifficultyLocks() {
        // Easy is always unlocked if user is verified
        if (currentUser && currentUser.emailVerified) {
            easyLockIcon.textContent = 'lock_open';
            easyBtn.classList.remove('locked');
            easyBtn.dataset.lockedByDifficulty = 'false'; // Mark as not locked by difficulty
            easyBtn.onclick = () => startQuiz("Easy");
        } else {
             // Keep locked if user is not verified
            easyLockIcon.textContent = 'lock';
            easyBtn.classList.add('locked');
            easyBtn.dataset.lockedByDifficulty = 'true';
            easyBtn.onclick = null;
        }


        // Medium
        if (completedDifficulties.Easy && currentUser && currentUser.emailVerified) {
            mediumLockIcon.textContent = 'lock_open';
            mediumBtn.classList.remove('locked');
            mediumBtn.dataset.lockedByDifficulty = 'false';
            mediumBtn.onclick = () => startQuiz("Medium");
        } else {
            mediumLockIcon.textContent = 'lock';
            mediumBtn.classList.add('locked');
            mediumBtn.dataset.lockedByDifficulty = 'true';
            mediumBtn.onclick = null; // Disable click
        }

        // Hard
        if (completedDifficulties.Medium && currentUser && currentUser.emailVerified) { // Hard unlocks after Medium
            hardLockIcon.textContent = 'lock_open';
            hardBtn.classList.remove('locked');
            hardBtn.dataset.lockedByDifficulty = 'false';
            hardBtn.onclick = () => startQuiz("Hard");
        } else {
            hardLockIcon.textContent = 'lock';
            hardBtn.classList.add('locked');
            hardBtn.dataset.lockedByDifficulty = 'true';
            hardBtn.onclick = null; // Disable click
        }
    }


    async function startQuiz(diff) {
        if (!currentUser || !currentUser.emailVerified) {
            await showMessageModal("Email Not Verified", "Please verify your email to start a quiz.");
            return;
        }

        // Prevent starting locked difficulties
        if (diff === "Medium" && !completedDifficulties.Easy) {
            await showMessageModal("Locked Difficulty", "Please complete the Easy difficulty first!");
            return;
        }
        if (diff === "Hard" && !completedDifficulties.Medium) {
            await showMessageModal("Locked Difficulty", "Please complete the Medium difficulty first!");
            return;
        }

        difficulty = diff;
        if (difficulty === "Easy") timePerQuestion = 20;
        else if (difficulty === "Medium") timePerQuestion = 15;
        else if (difficulty === "Hard") timePerQuestion = 10;

        quizData = await loadQuestions(diff);
        currentQuestion = 0;
        score = 0;
        correctAnswers = 0;
        scoreStreak = 0; // <--- ADD THIS LINE TO RESET STREAK
        startScreen.style.display = "none";
        quizScreen.style.display = "flex"; // Changed to flex for proper layout
        startTimer();
        document.getElementById("progress-bar").style.width = `0%`;
        showQuestion();
    }

    async function loadQuestions(difficulty) {
        const colRef = collection(db, difficulty.charAt(0).toUpperCase() + difficulty.slice(1));
        const snapshot = await getDocs(colRef);
        let questions = [];
        
        snapshot.forEach(doc => {
            const data = doc.data();
            questions.push({
                icon: `<span class="material-symbols-outlined">${data.icon}</span>`,
                options: shuffleArray([...data.options]),
                answer: data.answer
            });
        });
    
        // --- MODIFY THIS SECTION ---
        let numberOfQuestions = 10; // Default for Easy
        if (difficulty === "Medium") {
            numberOfQuestions = 15;
        } else if (difficulty === "Hard") {
            numberOfQuestions = 20;
        }
    
        return shuffleArray(questions).slice(0, numberOfQuestions);
        // --- END MODIFICATION ---
    }

    function shuffleArray(array) {
        return array.sort(() => Math.random() - 0.5);
    }

    function startTimer() {
        currentTimer = timePerQuestion;
        timerDisplay.textContent = `‚è±Ô∏è ${currentTimer}s`;

        clearInterval(timerInterval); // Clear previous timer if any

        timerInterval = setInterval(() => {
            currentTimer--;
            timerDisplay.textContent = `‚è±Ô∏è ${currentTimer}s`;
            if (currentTimer <= 0) {
                clearInterval(timerInterval);
                handleTimeUp();
            }
        }, 1000);
    }


    function showQuestion() {
        const q = quizData[currentQuestion];
        iconPlaceholder.innerHTML = q.icon;
        optionsDiv.innerHTML = "";
        progressText.textContent = `${currentQuestion + 1}/${quizData.length}`; // Fixed progress text
        document.getElementById("progress-bar").style.width = `${((currentQuestion + 1) / quizData.length) * 100}%`;
        questionStartTime = Date.now();

        q.options.forEach(option => {
            const btn = document.createElement("button");
            btn.classList.add("btn", "option");
            btn.textContent = option;
            btn.onclick = () => checkAnswer(btn, q.answer);
            optionsDiv.appendChild(btn);
        });

        startTimer(); // Ensure timer starts for each new question

    }

    function checkAnswer(selectedBtn, correctAnswer) {
        clearInterval(timerInterval); // Stop the timer when an answer is selected
        const timeTaken = (Date.now() - questionStartTime) / 1000;
        
        const buttons = document.querySelectorAll(".option");
        buttons.forEach(btn => {
            btn.disabled = true; // Disable all buttons
            if (btn.textContent === correctAnswer) {
                btn.classList.add("correct");
            } else {
                btn.classList.add("incorrect");
            }
        });
    
        if (selectedBtn.textContent === correctAnswer) {
            correctAnswers++;
            playCorrectSound(); // <--- CHANGE THIS LINE
            scoreStreak++; // <--- INCREMENT STREAK ON CORRECT ANSWER
        
            let multiplier = 0;
            let streakBonus = 0; // Initialize streak bonus
        
            if (difficulty === "Easy") {
                multiplier = timeTaken <= 5 ? 2.0 : timeTaken <= 15 ? 1.0 : 0.5;
            } else if (difficulty === "Medium") {
                multiplier = timeTaken <= 5 ? 3.0 : timeTaken <= 10 ? 2.0 : 1.0;
            } else if (difficulty === "Hard") {
                multiplier = timeTaken <= 3 ? 4.0 : timeTaken <= 7 ? 3.0 : 1.5;
            }
        
            const basePoints = Math.round(10 * multiplier);
        
            // --- NEW: Calculate streak bonus ---
            if (scoreStreak >= 2) { // Start giving bonus from 2 consecutive correct answers
                streakBonus = (scoreStreak - 1) * 5; // e.g., 2 streak = +5, 3 streak = +10, etc.
            }
            // --- END NEW ---
        
            const totalPointsEarned = basePoints + streakBonus; // Combine base and bonus
        
            score += totalPointsEarned;
            updateScoreUI(totalPointsEarned, scoreStreak); // <--- PASS scoreStreak to updateScoreUI
        } else {
            playIncorrectSound(); // <--- CHANGE THIS LINE
            scoreStreak = 0; // <--- RESET STREAK ON INCORRECT ANSWER
            updateScoreUI(0, scoreStreak); // <--- Pass 0 points and reset streak
        }
    
        setTimeout(() => {
            currentQuestion++;
            if (currentQuestion < quizData.length) {
                showQuestion();
            } else {
                clearInterval(timerInterval);
                showScore();
            }
        }, 1000);
    }

    async function showScore() {
        setTimeout(async () => {
            const displayName = currentUser.displayName || currentUser.email;

            try {
                if (currentUser && currentUser.emailVerified) {
                    await uploadToLeaderboard(displayName, score, correctAnswers, difficulty);
                    await updateCompletedDifficulty(difficulty);

                    // Upload successful:
                    // 1. Show "Quiz Complete!" modal and await its dismissal.
                    await showMessageModal(
                        "Quiz Complete!",
                        `Score: ${score}\nCorrect Answers: ${correctAnswers}\nScore uploaded!`
                        // No autoCloseDelay here, user clicks OK
                    );

                    // 2. Then show "Play Again?" modal and await its dismissal.
                    // The "Play Again?" prompt still uses a single OK button to continue.
                    await showMessageModal(
                        "Play Again?",
                        "Would you like to try another quiz?"
                        // No autoCloseDelay here, user clicks OK
                    );
                    location.reload(); // Reload after "Play Again?" is dismissed
                } else {
                    // Not verified/logged in (score not uploaded):
                    // 1. Show "Quiz Complete!" modal and await its dismissal.
                    await showMessageModal(
                        "Quiz Complete!",
                        `Score: ${score}\nCorrect Answers: ${correctAnswers}\nYour score could not be uploaded because you are not logged in or your email is not verified.`
                    );

                    // 2. Then show "Play Again?" modal and await its dismissal.
                    await showMessageModal(
                        "Play Again?",
                        "Would you like to try another quiz?"
                    );
                    location.reload(); // Reload after "Play Again?" is dismissed
                }

            } catch (error) {
                // This catch block will be hit if `uploadToLeaderboard` threw an error.
                // `uploadToLeaderboard` already showed its specific "Upload Failed" message.
                // Because `showMessageModal` now returns a Promise, we can rely on that.
                console.error("Quiz completion upload process failed:", error);

                // Just show the "Play Again?" modal. The error modal (from uploadToLeaderboard)
                // will have either auto-closed or been dismissed by the user.
                await showMessageModal(
                    "Play Again?",
                    "Would you like to try another quiz?"
                );
                location.reload(); // Reload after "Play Again?" is dismissed
            }

        }, 200);
    }

    async function updateCompletedDifficulty(completedDiff) {
        if (!currentUser || !currentUser.emailVerified) return; // Ensure verified before updating
        const userRef = doc(db, "users", currentUser.uid);

        // Set the corresponding completed difficulty flag to true
        const updateData = {};
        if (completedDiff === "Easy") updateData.completedEasy = true;
        else if (completedDiff === "Medium") updateData.completedMedium = true;
        else if (completedDiff === "Hard") updateData.completedHard = true;

        if (Object.keys(updateData).length > 0) {
            try {
                await updateDoc(userRef, updateData);
                console.log(`User ${currentUser.uid} completed ${completedDiff} difficulty.`);
                // Update the local state for completed difficulties
                completedDifficulties[completedDiff] = true;
                // Re-evaluate locks immediately
                updateDifficultyLocks();
            } catch (error) {
                console.error("Error updating user's completed difficulty:", error);
                // Do not show a modal here, it's a background update for the user.
                // If critical, handle appropriately, but usually not user-facing.
            }
        }
    }

    async function uploadToLeaderboard(name, score, correct, difficulty) {
        const user = auth.currentUser;
        if (!user) {
            console.error("No user authenticated. Score not uploaded.");
            await showMessageModal("Upload Failed", "You must be logged in to upload your score.", 5000);
            throw new Error("User not authenticated.");
        }

        try {
            await user.reload();
            console.log("User emailVerified status after reload:", user.emailVerified);
        } catch (reloadError) {
            console.error("Error reloading user for verification check:", reloadError);
            await showMessageModal("Upload Failed", "Could not verify your account status. Please try logging in again.", 5000);
            throw new Error("Failed to reload user for verification.");
        }

        if (!user.emailVerified) {
            console.error("User email not verified. Score not uploaded.");
            await showMessageModal("Upload Failed", "Your score could not be uploaded because your email is not verified. Please check your email inbox and click the verification link. After verifying, please log out and log back in to refresh your account status.", 8000);
            throw new Error("User email not verified.");
        }

        const currentTime = Date.now();
        const creationTime = user.metadata.creationTime;
        const oneMinute = 60 * 1000;

        if (creationTime && (currentTime - creationTime < oneMinute)) {
            console.warn("New user, potentially first write. Ensure token is fresh.");
        }

        const leaderboardRef = doc(db, "Leaderboard", user.uid);
        const userRef = doc(db, "users", user.uid);

        try {
            const docSnap = await getDoc(leaderboardRef);

            if (docSnap.exists()) {
                const data = docSnap.data();
                await updateDoc(leaderboardRef, {
                    score: (data.score || 0) + score,
                    correct: (data.correct || 0) + correct,
                    quizzesCompleted: (data.quizzesCompleted || 0) + 1,
                    lastPlayed: serverTimestamp()
                });
            } else {
                await setDoc(leaderboardRef, {
                    name: user.displayName || name || "Anonymous",
                    score: score,
                    correct: correct,
                    difficulty: difficulty,
                    quizzesCompleted: 1,
                    timestamp: serverTimestamp()
                });
            }

            const userSnap = await getDoc(userRef);
            const userData = userSnap.exists() ? userSnap.data() : {};

            if (userSnap.exists()) {
                await updateDoc(userRef, {
                    totalQuizzes: (userData.totalQuizzes || 0) + 1,
                    highScore: Math.max(score, userData.highScore || 0)
                });
            } else {
                await setDoc(userRef, {
                    totalQuizzes: 1,
                    highScore: score
                });
            }

            console.log(`User ${user.uid} completed ${difficulty} difficulty.`);
        }
        catch (error) {
            console.error("Error uploading to leaderboard:", error);
            if (error.code === 'permission-denied' || error.message.includes('Missing or insufficient permissions') || error.message.includes('Bad Request') || error.message.includes('BLOCKED_BY_CLIENT')) {
                const creationTime = user && user.metadata.creationTime ? new Date(user.metadata.creationTime).getTime() : 0;
                const fiveMinutes = 5 * 60 * 1000;

                if (creationTime && (currentTime - creationTime < fiveMinutes)) {
                    await showMessageModal(
                        "Upload Failed",
                        "Your score could not be uploaded because your email is not verified or you have already verified it but after logging in, if so kindly re-logged in again, thank you.",
                        12000
                    );
                } else {
                    await showMessageModal(
                        "Upload Failed",
                        "There was an issue uploading your score. If this is a new account, please ensure your email is verified. Then, **log out and log back in** to fully activate your account and try again.",
                        8000
                    );
                }
            } else {
                await showMessageModal(
                    "Upload Failed",
                    "An unexpected error occurred. Please try again.",
                    5000
                );
            }
            throw error; // Always re-throw the error on failure for showScore to catch it
        }
    }

    function handleTimeUp() {
        const q = quizData[currentQuestion];

        const buttons = document.querySelectorAll(".option");
        buttons.forEach(btn => {
            btn.disabled = true;
            if (btn.textContent === q.answer) {
                btn.classList.add("correct");
            } else {
                btn.classList.add("incorrect");
            }
        });
        playIncorrectSound(); // <--- CHANGE THIS LINE (if time runs out, it's like an incorrect answer)
        scoreStreak = 0; // <--- RESET STREAK WHEN TIME IS UP
        updateScoreUI(0, scoreStreak); // <--- Pass 0 points and reset streak

        setTimeout(() => {
            currentQuestion++;
            if (currentQuestion < quizData.length) {
                showQuestion();
            } else {
                clearInterval(timerInterval);
                showScore();
            }
        }, 1000);
    }

    // Get the new streak feedback element
const streakFeedback = document.getElementById("streak-feedback"); // Add this line near other element queries

    function updateScoreUI(points, currentStreak) { // currentStreak is already passed from previous steps
        totalScoreDisplay.textContent = `Score: ${score}`;

        // Update score feedback (existing logic)
        if (points > 0) {
            scoreFeedback.textContent = `+${points}`;
            scoreFeedback.classList.add("show");
        } else {
            scoreFeedback.classList.remove("show");
            scoreFeedback.textContent = "";
        }

        // Update streak feedback (existing logic)
        if (currentStreak >= 2) {
            streakFeedback.textContent = `üî• ${currentStreak}x Streak!`;
            streakFeedback.classList.add("show");
        } else {
            streakFeedback.classList.remove("show");
            streakFeedback.textContent = "";
        }

        // --- NEW: Handle Background Color Change based on Streak ---

        // 1. Remove all existing streak background classes from the body
        const bodyClasses = Array.from(document.body.classList); // Get current classes as array
        bodyClasses.forEach(className => {
            if (className.startsWith('streak-') && className.endsWith('-bg')) {
                document.body.classList.remove(className);
            }
        });

        // 2. Add the appropriate new streak background class
        if (currentStreak >= 2) {
            // We'll apply the specific background for streaks 2 through 9.
            // For streaks 10 and above, we'll use the 'streak-10-bg' class.
            let streakBgClass = '';
            if (currentStreak >= 10) {
                streakBgClass = 'streak-10-bg';
            } else if (currentStreak >= 2) { // For streaks 2 to 9
                streakBgClass = `streak-${currentStreak}-bg`;
            }

            if (streakBgClass) {
                document.body.classList.add(streakBgClass);
            }
        } else {
            // If streak is 0 or 1, ensure the default primary gradient is applied
            // (which is defined in your initial body styles). No specific streak class is needed.
            // The filtering above already removes any existing streak classes.
        }

        // --- END NEW BACKGROUND LOGIC ---


        // Hide feedback after a delay (existing logic)
        setTimeout(() => {
            scoreFeedback.classList.remove("show");
            scoreFeedback.textContent = "";
            // You might want streakFeedback to stay longer or fade out with points.
            // If you want it to fade out here too:
            // streakFeedback.classList.remove("show");
            // streakFeedback.textContent = "";
        }, 800);
    }

    const bgMusic = document.getElementById("bg-music");
    // const correctSound = document.getElementById("correct-sound"); // REMOVE OR COMMENT OUT THIS LINE
    // const incorrectSound = document.getElementById("incorrect-sound"); // REMOVE OR COMMENT OUT THIS LINE
    
    // NEW: Define functions to play sounds dynamically
    function playCorrectSound() {
        const sound = new Audio('sounds/correct.mp3');
        sound.volume = 1.0; // Set volume here
        sound.play().catch(e => console.error("Error playing correct sound:", e));
    }
    
    function playIncorrectSound() {
        const sound = new Audio('sounds/incorrect.mp3');
        sound.volume = 1.0; // Set volume here
        sound.play().catch(e => console.error("Error playing incorrect sound:", e));
    }

    bgMusic.volume = 0.1;




    window.onload = () => {
        // Event listeners for difficulty buttons are now managed by updateDifficultyLocks
        // which is called after user login and quiz completion.
        // Initial call to updateDifficultyLocks will set them up correctly.

        // Certificate functionality
        claimCertificateBtn.addEventListener("click", async () => {
            if (!currentUser) {
                await showMessageModal("Login Required", "Please log in to claim your certificate.");
                window.location.href = "auth.html"; // Redirect if not logged in
                return;
            }

            // NEW: Email verification check for claiming certificate
            if (!currentUser.emailVerified) {
                await showMessageModal("Email Not Verified", "Please verify your email address to claim your certificate.");
                return;
            }

            // For certificate, let's make it available only if all difficulties are completed.
            if (!completedDifficulties.Easy || !completedDifficulties.Medium || !completedDifficulties.Hard) {
                await showMessageModal("Certificate Locked", "Complete all difficulties (Easy, Medium, and Hard) to earn your certificate!");
                return;
            }


            const userName = currentUser.displayName || "Valued User"; // Get user's name
            const today = new Date();
            const completionDate = today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

            // Load the certificate template image
            const certificateImage = new Image();
            // Assuming your images folder is at the root level or accessible via /images/
            certificateImage.src = '/images/certificate-template.png';

            certificateImage.onload = () => {
                // Set canvas dimensions to match the image
                certificateCanvas.width = certificateImage.width;
                certificateCanvas.height = certificateImage.height;

                // Draw the background image
                ctx.drawImage(certificateImage, 0, 0);

                // Set text styles for the name
                ctx.font = 'bold 100px Fredoka'; // Adjust font size and family as needed
                ctx.fillStyle = '#2E0B40'; // Adjust color to match your design (dark purple from your CSS)
                ctx.textAlign = 'center';

                // Draw the user's name on the underline
                // You'll need to adjust these coordinates (x, y) based on your image's layout
                // x: horizontal center of the canvas
                // y: estimated vertical position of the underline
                const nameX = certificateCanvas.width / 2;
                const nameY = certificateCanvas.height * 0.49; // Adjust this '0.53' multiplier as needed

                ctx.fillText(userName.toUpperCase(), nameX, nameY); // Convert name to uppercase if preferred

                // Set text styles for the date
                ctx.font = '30px IBM Plex Sans'; // Adjust font size and family
                ctx.fillStyle = '#2E0B40'; // Same color as name
                ctx.textAlign = 'center';

                // Draw the date below MindBlast
                // x: horizontal center of the canvas
                // y: estimated vertical position below MindBlast
                const dateX = certificateCanvas.width / 2;
                const dateY = certificateCanvas.height * 0.9; // Adjust this '0.86' multiplier as needed

                ctx.fillText(completionDate, dateX, dateY);

                // Show the modal
                certificateModal.style.display = "flex";

                // Set the download link for the generated certificate
                downloadCertificateBtn.onclick = () => {
                    const dataURL = certificateCanvas.toDataURL('image/png'); // Get image data as PNG
                    const link = document.createElement('a');
                    link.href = dataURL;
                    link.download = `${userName}_MindBlast_Certificate.png`; // Dynamic download filename
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                };
            };

            certificateImage.onerror = () => {
                console.error("Failed to load certificate template image. Make sure the path is correct.");
                showMessageModal("Error", "Could not load certificate template. Please try again later.");
            };
        });

        closeModalBtn.addEventListener("click", () => {
            certificateModal.style.display = "none";
        });

        // Close modal if user clicks outside of it
        window.addEventListener("click", (event) => {
            if (event.target == certificateModal) {
                certificateModal.style.display = "none";
            }
        });

        // Quit Confirmation Logic
        closeQuizBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Prevent default link navigation
            clearInterval(timerInterval); // Stop quiz timer if it's running
            quitConfirmModal.style.display = 'flex'; // Show the modal
        });

        quitYesBtn.addEventListener('click', () => {
            window.location.href = 'home.html'; // User confirmed, navigate away
        });

        quitNoBtn.addEventListener('click', () => {
            quitConfirmModal.style.display = 'none'; // User cancelled, hide modal
            // If the quiz was in progress, resume timer
            if (quizScreen.style.display === 'flex' && currentTimer > 0) {
                startTimer();
            }
        });

        // Also allow clicking outside to close (optional, but good UX)
        window.addEventListener('click', (event) => {
            if (event.target === quitConfirmModal) {
                quitConfirmModal.style.display = 'none';
                // If the quiz was in progress, resume timer
                if (quizScreen.style.display === 'flex' && currentTimer > 0) {
                    startTimer();
                }
            }
        });
    };
    </script>
</body>
</html>